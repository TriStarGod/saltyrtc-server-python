#!/usr/bin/env python3
"""
The command line interface for the SaltyRTC signalling server.
"""
import functools
import asyncio

import click

from saltyrtc.server import __version__ as _version
from saltyrtc import server


def aio_run(func, run_forever=False):
    func = asyncio.coroutine(func)

    def _wrapper(*args, **kwargs):
        loop = asyncio.get_event_loop()
        task = loop.create_task(func(*args, **kwargs))
        loop.run_until_complete(task)
        if run_forever:
            loop.run_forever()
        return task.result()
    return functools.update_wrapper(_wrapper, func)


def aio_serve(func):
    return aio_run(func, run_forever=True)


@click.group()
@click.pass_context
def cli(ctx):
    """
    Command Line Interface. Use --help for details.
    """
    ctx.obj = {}


@cli.command(short_help='Show version information.', help="""
Show the current version of the SaltyRTC signalling server.
""")
def version():
    click.echo('Version: {}'.format(_version))


@cli.command(short_help='Start the signalling server.', help="""
Start the SaltyRTC signalling server. CERT represents the path to a
file in PEM format containing the SSL certificate of the server.""")
@click.argument('cert', type=click.Path(exists=True))
@click.option('-k', '--keyfile', type=click.Path(exists=True), help="""
Path to a file that contains the private key. Will be read from
CERTFILE if not present.
""")
@aio_serve
def serve(**arguments):
    certfile = arguments.get('cert')
    keyfile = arguments.get('keyfile', None)
    yield from server.start_server(
        certfile=certfile, keyfile=keyfile
    )


if __name__ == '__main__':
    with server.logging_handler.applicationbound():
        try:
            cli()
        except Exception as exc:
            click.echo('An error occurred:', err=True)
            click.echo(exc, err=True)
